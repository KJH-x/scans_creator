import json
from typing import Dict, List, Union


def generate_type_annotation(schema):
    """
    Generates Python type annotations from a JSON schema.
    
    Args:
        schema (dict): JSON schema object.
    
    Returns:
        str: Python type annotation.
    """
    print(f"Searching {schema}")

    # Handle "anyOf", "oneOf" (Union types)
    if 'anyOf' in schema or 'oneOf' in schema:
        types = []
        for subschema in schema.get('anyOf', schema.get('oneOf', [])):
            types.append(generate_type_annotation(subschema))
        return " | ".join(types)


    if 'type' not in schema:
        # {'path': {'type': 'string'}}
        # if len(keys:=schema.keys()):
        #     keys[0]
        return "Any"  # Fallback to Any if no type is found
    
    schema_type = schema['type']
    
    # Handle basic types
    if schema_type == "string":
        return "str"
    elif schema_type == "integer":
        return "int"
    elif schema_type == "boolean":
        return "bool"
    elif schema_type == "object":
        # If it's an object, check if it has properties
        if 'properties' in schema:
            for key in schema['properties'].keys():
                if schema['properties'][key]['type'] != "object":
                    # last recursive
                    return f"Dict[str, {generate_type_annotation(schema['properties'][key])}]"
                else:
                    return f"Dict[str, {generate_type_annotation({'type': 'object', 'properties': schema['properties']})}]"
        return "Dict[str, Any]"
    elif schema_type == "array":
        items = schema.get("items")
        if items:
            return f"List[{generate_type_annotation(items)}]"
        return "List[Any]"
    

    
    return "Any"  # Fallback to Any

def generate_jsonload_class_with_types(schema_file, output_file):
    """
    Generates a Python file with a JSONLOAD class, including type annotations, based on a given JSON schema.
    
    Args:
        schema_file (str): Path to the JSON schema file.
        output_file (str): Path to the output Python file.
    """
    # Load the JSON schema
    with open(schema_file, 'r') as f:
        schema = json.load(f)
    
    # Extract properties from the schema
    properties = schema.get("properties", {})
    
    # Generate class properties, initialization and type annotations
    class_content = [
        "# This file is generated by ConfigPorperties.generator.py, do not modify this file directly.",
        "import json",
        "from typing import List, Dict",
        "",
        "",
        "class JSONLOAD:",
        "    def __init__(self, config_file: str):",
        "        \"\"\"Initialize JSONLOAD by loading a JSON configuration file.\"\"\"",
        "        with open(config_file, 'r') as f:",
        "            json_object = json.load(f)",
    ]
    
    # Add properties with type annotations and initialization
    for prop, details in properties.items():
        type_annotation = generate_type_annotation(details)
        class_content.append(f"        self.{prop}: {type_annotation} = json_object.get('{prop}', None)  # {details.get('description', '')}")
    
    # Add a method to display the loaded configuration (optional)
    class_content.extend([
        "",
        "    def __repr__(self) -> str:",
        "        return str(self.__dict__)",
    ])
    
    # Write the generated class to a file
    with open(output_file, 'w') as f:
        f.write("\n".join(class_content))
    
    print(f"Generated JSONLOAD class with type annotations in {output_file}")


# Example usage
generate_jsonload_class_with_types('schemas/info_layout.schema.json', 'ConfigPorperties.py')
